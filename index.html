<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>PROJETOS DE PDI by yuripedro</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">PROJETOS DE PDI</h1>
        <p class="header">YURI PEDRO DOS SANTOS</p>



        <ul>
          <li><a class="buttons github" href="https://github.com/yuripedro">GitHub Profile</a></li>
        </ul>

      </header>
      <section>
<h3>Programa regions.cpp</h3>
<p> Foi solicitada a implementação de um algoritmo que, dadas as coordenadas de dois
pontos P1 e P2 localizados dentro dos limites do tamanho da imagem, inverta a coloração dos
pixels que se encontram dentro da área delimitada por P1 e P2. O algoritmo solicita a imagem e as coordenadas ao usuário e,
com essas informações, percorre toda a imagem até chegar na região desejada. Quando a região é encontrada para cada pixel
da região é pego o seu valor (em tom de cinza), esse valor é subtraído de 255 (branco) e então
é armazenado novamente no pixel. Invertendo assim a região definida pelo usuário.</p>
<figure>
<div>
	<p>
		Imagem Original
	</p>
	
</div>	
 <img src="gotg.png" alt="Imagem Original" title="Imagem Original"  />
 
 <div>
	<p>
		Imagem Processada
	</p>
	
</div>
<img src="RegionsImg.png" alt="Imagem Processada" title="Imagem Processada"  />
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="Regions.png" alt="Código" title="Código"  />
</figure>


<h3>Programa trocaregions.cpp</h3>
<p> Esse programa deverá trocar aleatoriamente regiões da imagem, formando uma espécie de quebra-cabeças. Para isso foi usado uma
função chamada rect que vai delimitar as regiões da imagem, em seguida é criada um clone da imagem recebida e mais uma vez é delimitada
as regiões, mas dessa vez as do clone, depois as regiões, cada uma armazenada em uma matriz, foram jogadas em  regiões diferentes
das originais, mas na imagem clone.</p>
<figure>
<div>
	<p>
		Imagem Original
	</p>
	
</div>	
 <img src="gotg.png" alt="Imagem Original" title="Imagem Original"  />
 
 <div>
	<p>
		Imagem Processada
	</p>
	
</div>
<img src="TrocaRegionsImg.png" alt="Imagem Processada" title="Imagem Processada"  />
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="TrocaRegions.png" alt="Código" title="Código"  />
</figure>

<h3>Problema do programa labeling.cpp</h3>
<p>Existe um problema em uma imagem com mais de 255 objetos, pois cada objeto contado é rotulado com um tom de cinza diferente,
como existem 255 tons de cinza, só seria possível contar até 255. A solucao seria guardar os valores contados em uma variavel 
auxiliar e resetar a contagem.</p>
<figure>
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="LabelingPrimeiro.png" alt="Código" title="Código"  />
</figure>
<h3>Novo programa labeling.cpp</h3>
<p>O exercício pede que sejam identificadas regiões com ou sem buracos internos em uma
imagem, assumindo que objetos com mais de um buraco podem existir e que as bolhas que
tocam as bordas não sejam contadas.
As bordas da imagem são pintadas de branco para separar os buracos que a tocam e então é
feito um floodfill no primeiro pixel da imagem para pintar toda a borda e os buracos que a tocam
de preto. Feito isso é aplicado o floodfill mais uma vez no primeiro pixel da imagem para todo o
background ser preenchido com tom de cinza 1. A imagem é percorrida e sempre que for
encontrado um pixel com valor 255 uma variável é incrementada para contar a quantidade total
de objetos e todos os objetos são rotulados como sem buraco. Uma convenção é utilizada para
rotular os objetos: tom de cinza 150 = sem buraco e tom de cinza 50 = com buraco. A imagem
é percorrida novamente e, sempre que for encontrado um pixel com rótulo com buraco ou sem
buraco, suas coordenadas x e y são armazenadas na variável p. O laço é continuado até ser
encontrado um pixel com tom de cinza 0 (buraco). Caso isso aconteça é aplicado o floodfill no
último elemento p encontrado e o elemento é rotulado como com buraco e o buraco encontrado
também é rotulado como com buraco para que o mesmo não seja encontrado novamente. Se o
elemento p já tiver sido rotulado como com buraco o floodfill não é utilizado.</p>
<figure>
<div>
	<p>
		Imagem Original
	</p>
	
</div>	
 <img src="bolhas.png" alt="Imagem Original" title="Imagem Original"  />
 
 <div>
	<p>
		Imagem Processada
	</p>
	
</div>
<img src="labeling.png" alt="Imagem Processada" title="Imagem Processada"  />
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="parte01novo.png" alt="Código" title="Código"  />
<img src="parte2.png" alt="Código" title="Código"  />
<img src="parte03.png" alt="Código" title="Código"  />
</figure>
<h3>Programa equalize.cpp</h3>
<p>É pedido que o algoritmo implementado, antes de apresentar a imagem, faça uma
equalização do histograma da imagem original e apresente depois a imagem equalizada.
A solução encontrada foi converter a imagem do formato RGB para YCrCb, pois este padrão
separa a intensidade luminosa dos outros componentes de cor, equalizar o histograma e então
converter a imagem de volta para o padrão RGB.</p>
<figure>
<div>
	<p>
		Imagem Original
	</p>
	
</div>	
 <img src="equalizeorig.png" alt="Imagem Original" title="Imagem Original"  />
 
 <div>
	<p>
		Imagem Processada
	</p>
	
</div>
<img src="equalizedImage.png" alt="Imagem Processada" title="Imagem Processada"  />
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="equalizecod.png" alt="Código" title="Código"  />
</figure>
<h3>Programa motiondetector.cpp</h3>
<p>Este programa  calcular  continuamente o histograma da imagem 
(apenas uma componente de cor ) e o compara com o último histograma calculado. 
Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, é ativado um alarme. Para
implementar este programa foram criadas mais duas imagens, uma auxiliar e outra antiga, a imagem auxiliar vai armazenar
a imagem atual, depois a atual é comparada com a antiga e depois a imagem antiga recebe a auxiliar, quando a diferença ultrapassar
o limiar de 15, toda a tela fica azul(nesse caso amarelo, pois o tom de azul escolhido foi baixo).</p>
<figure>
 <div>
	<p>
		Imagem Processada
	</p>
	
</div>
<img src="motion.png" alt="Imagem Processada" title="Imagem Processada"  />
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="motion01.png" alt="Código" title="Código"  />
<img src="motion02.png" alt="Código" title="Código"  />
<img src="motion03.png" alt="Código" title="Código"  />
</figure>

<h3>Programa laplgauss.cpp</h3>
<p>No algoritmo original foi incluída a opção Laplaciano do Gaussiano e, quando é selecionada,
aplica o filtro gaussiano e no resultado aplica o filtro Laplaciano. O filtro gaussiano atenua o ruído e, quando é
aplicado o filtro laplaciano, as bordas se tornam mais fáceis de identificar.</p>
<figure>
 <div>
	<p>
		Filtro Laplaciano
	</p>
	
</div>
<img src="laplaciano.png" alt="Filtro Laplaciano" title="Filtro Laplaciano"  />
 <div>
	<p>
		Filtro Laplaciano do Gaussiano
	</p>
	
</div>
<img src="laplaciano do gaussiano.png" alt="Filtro Laplaciano do Gaussiano" title="Filtro Laplaciano do Gaussiano"  />
 <div>
	<p>
		Código
	</p>
	
</div>
<img src="prog7.png" alt="Código" title="Código"  />
<img src="prog7parte2.png" alt="Código" title="Código"  />
<img src="prog7parte3.png" alt="Código" title="Código"  />
<img src="prog7parte4.png" alt="Código" title="Código"  />
</figure>
<!--escrver conteudo aqui texto usa p, titulo é h3 -->
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
